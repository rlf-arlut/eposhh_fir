// SPDX-FileCopyrightText: 2023 Board of Regents, The University of Texas System
// SPDX-FileAttributionText: <text>This software was developed with government support under Grant no. DE-SC0023055 awarded by the Department of Energy. The government has certain rights in the copyright.</text>
//
// SPDX-License-Identifier: BSD-3-Clause

/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./fir_top_i2c_tmrTMR.v                                                                 *
 *                                                                                                  *
 * user    : rfriesen                                                                               *
 * host    : sgl-lap054                                                                             *
 * date    : 11/09/2023 23:04:44                                                                    *
 *                                                                                                  *
 * workdir : /home/rfriesen/git/eposhh_fir5tap/rtl                                                  *
 * cmd     : /home/rfriesen/git/tmrg/bin/tmrg -v -c fir_top_i2c_tmr.cnf --no-common-definitions     *
 *           --generate-report fir_top_i2c_tmr.v adder_tree10.v crc16TMR.v snapshot_txTMR.v         *
 *           i2c_targetTMR.v i2c_target_wbcTMR.v snapshot_txTMR.v mult_reg.v voter.v fanout.v       *
 * tmrg rev: 6574161d3b316703ff7c8948d3a894c6005f77d4                                               *
 *                                                                                                  *
 * src file: fir_top_i2c_tmr.v                                                                      *
 *           Git SHA           : 3085884715ef2d551fb103418077003dafbfce9c ( M fir_top_i2c_tmr.v)    *
 *           Modification time : 2023-09-11 23:03:58.602331                                         *
 *           File Size         : 14223                                                              *
 *           MD5 hash          : 78065e80df57a12e70d1897de5b3a09a                                   *
 *                                                                                                  *
 ****************************************************************************************************/

`default_nettype  none
module fir_top_i2c_tmr #(
  parameter [6:0] I2C_ADDR  = 7'h2E,
  parameter  SAMPLE_WIDTH  = 16,
  parameter  COEF_WIDTH  = 16,
  parameter  NUM_TAPS  = 10
)(
  input wire  clk ,
  input wire  rst ,
  input wire  i2c_scl_i ,
  output wire  i2c_scl_o ,
  output wire  i2c_scl_t ,
  input wire  i2c_sda_i ,
  output wire  i2c_sda_o ,
  output wire  i2c_sda_t ,
  input wire [7:0] sample_i ,
  output reg  pdw_data ,
  output reg  pdw_frame 
);
localparam [31:0] ZEROS =0;
localparam WB_DATA_WIDTH =16;
localparam WB_ADDR_WIDTH =16;
localparam WB_SELECT_WIDTH =2;
localparam RMH =7;
localparam RML =5;
localparam RAH =4;
localparam RAL =1;
localparam RM_COEF =0;
localparam RM_THRESH =1;
localparam RM_CTRL =2;
localparam RA_CTRL =0;
localparam RB_CTRL_EN =0;
localparam RA_SS_DELAY =1;
localparam RF_SS_DELAY =0;
localparam RF_SS_DELAY_WIDTH =$clog2(NUM_TAPS);
localparam RB_REPLACE_LARGE_MAG =1;
localparam RB_REPLACE_MORE_POS =2;
localparam RB_REPLACE_MORE_NEG =3;
localparam RB_REPLACE_NEVER =11;
localparam PRODUCT_WIDTH =COEF_WIDTH+SAMPLE_WIDTH;
localparam ABS_TIME_WIDTH =32;
localparam SAMPLE_BUFFER_SZ =NUM_TAPS+1+$clog2(NUM_TAPS);
localparam SS_BUFF_SZ =(SAMPLE_WIDTH*NUM_TAPS)+ABS_TIME_WIDTH;
wire wb_weC;
wire wb_weB;
wire wb_weA;
wire wb_stbC;
wire wb_stbB;
wire wb_stbA;
wire [WB_DATA_WIDTH-1:0] wb_dat_oC;
wire [WB_DATA_WIDTH-1:0] wb_dat_oB;
wire [WB_DATA_WIDTH-1:0] wb_dat_oA;
wire [WB_ADDR_WIDTH-1:0] wb_adr_oC;
wire [WB_ADDR_WIDTH-1:0] wb_adr_oB;
wire [WB_ADDR_WIDTH-1:0] wb_adr_oA;
wire ss_tx_idleC;
wire ss_tx_idleB;
wire ss_tx_idleA;
wire ss_load_enC;
wire ss_load_enB;
wire ss_load_enA;
wire [RF_SS_DELAY_WIDTH-1:0] ss_delay_cntrC;
wire [RF_SS_DELAY_WIDTH-1:0] ss_delay_cntrB;
wire [RF_SS_DELAY_WIDTH-1:0] ss_delay_cntrA;
wire rstC;
wire rstB;
wire rstA;
wire clkC;
wire clkB;
wire clkA;
wire thresholdsTmrError;
wire signed  [15:0] thresholds [ 0 : 5 ] ;
wire ss_delayTmrError;
wire [RF_SS_DELAY_WIDTH-1:0] ss_delay;
wire ss_buff_validTmrError;
wire ss_buff_valid;
wire controlTmrError;
wire [3:0] control;
wire coeffTmrError;
wire [COEF_WIDTH-1:0] coeff [ 9 : 0 ] ;
wire abs_time_cntrTmrError;
wire [ABS_TIME_WIDTH-1:0] abs_time_cntr;
reg  [WB_DATA_WIDTH-1:0] wb_dat_i ;
reg  [WB_DATA_WIDTH-1:0] wb_dat_i_mux ;
wire [WB_DATA_WIDTH-1:0] wb_dat_o;
wire [WB_ADDR_WIDTH-1:0] wb_adr_o;
wire [1:0] wb_sel;
wire wb_we;
wire wb_stb;
wire wb_cyc;
reg  wb_ack ;
wire busy;
wire bus_addressed;
wire bus_active;
reg  [3:0] controlA ;
reg  [3:0] controlB ;
reg  [3:0] controlC ;
reg  [RF_SS_DELAY_WIDTH-1:0] ss_delayA ;
reg  [RF_SS_DELAY_WIDTH-1:0] ss_delayB ;
reg  [RF_SS_DELAY_WIDTH-1:0] ss_delayC ;
reg signed  [15:0] thresholdsA [ 0 : 5 ] ;
reg signed  [15:0] thresholdsB [ 0 : 5 ] ;
reg signed  [15:0] thresholdsC [ 0 : 5 ] ;
reg signed  [15:0] thresholds_readback ;
reg  [COEF_WIDTH-1:0] coeffA [ 9 : 0 ] ;
reg  [COEF_WIDTH-1:0] coeffB [ 9 : 0 ] ;
reg  [COEF_WIDTH-1:0] coeffC [ 9 : 0 ] ;
reg  [COEF_WIDTH-1:0] coeff_readback ;
reg signed  [PRODUCT_WIDTH-1:0] products [ NUM_TAPS-1 : 0 ] ;
reg  [(PRODUCT_WIDTH*NUM_TAPS)-1:0] products_1d ;
wire signed  [(PRODUCT_WIDTH+$clog2(NUM_TAPS))-1:0] fir_out;
wire signed  [(PRODUCT_WIDTH+$clog2(NUM_TAPS))-1:0] abs_fir_out;
reg signed  [(PRODUCT_WIDTH+$clog2(NUM_TAPS))-1:0] ss_fir_out ;
wire signed  [35:0] threshold_hi;
wire signed  [35:0] threshold_lo;
reg  [SAMPLE_WIDTH-1:0] samples [ SAMPLE_BUFFER_SZ-1 : 0 ] ;
reg  [SAMPLE_WIDTH/2-1:0] sample_in_pos ;
reg  [SAMPLE_WIDTH/2-1:0] sample_in_neg ;
reg  [SS_BUFF_SZ-1:0] ss_buff ;
reg  [ABS_TIME_WIDTH-1:0] abs_time_cntrA ;
reg  [ABS_TIME_WIDTH-1:0] abs_time_cntrB ;
reg  [ABS_TIME_WIDTH-1:0] abs_time_cntrC ;
wire fir_out_gte_thresh_hi;
wire fir_out_lte_thresh_lo;
wire fir_out_gt_ss_fir_out;
wire fir_out_lt_ss_fir_out;
wire ss_load_en_hi;
wire ss_load_en_lo;
wire ss_load_en_mag;
wire ss_load_en;
reg  ss_buff_validA ;
reg  ss_buff_validB ;
reg  ss_buff_validC ;
reg  [RF_SS_DELAY_WIDTH-1:0] ss_delay_cntr ;
wire ss_tx_idle;
wire ss_tx_start;
integer i;

always @( posedge clk )
  begin
    sample_in_pos <= sample_i;
    samples[0]  <= {sample_in_pos,sample_in_neg};
    for(i =  SAMPLE_BUFFER_SZ-1;i>0;i =  i-1)
      samples[i]  <= samples[i-1] ;
  end

always @( negedge clk )
  begin
    sample_in_neg <= sample_i;
  end

always @( posedge clk )
  wb_ack <= wb_stb&~wb_ack;
integer tap;
integer th;

always @( posedge clkA )
  begin
    if (rstA==1'b1)
      begin
        controlA[RB_CTRL_EN]  <= 0;
        abs_time_cntrA <= 0;
      end
    else
      begin
        abs_time_cntrA <= abs_time_cntrA+1;
        if ((wb_adr_oA[WB_ADDR_WIDTH-1:RMH+1] ==0)&&(wb_adr_oA[RMH:RML] ==RM_CTRL)&&(wb_adr_oA[RAH:RAL] ==RA_CTRL)&&wb_weA&&wb_stbA)
          begin
            controlA <= wb_dat_oA[3:0] ;
          end
      end
  end

always @( posedge clkB )
  begin
    if (rstB==1'b1)
      begin
        controlB[RB_CTRL_EN]  <= 0;
        abs_time_cntrB <= 0;
      end
    else
      begin
        abs_time_cntrB <= abs_time_cntrB+1;
        if ((wb_adr_oB[WB_ADDR_WIDTH-1:RMH+1] ==0)&&(wb_adr_oB[RMH:RML] ==RM_CTRL)&&(wb_adr_oB[RAH:RAL] ==RA_CTRL)&&wb_weB&&wb_stbB)
          begin
            controlB <= wb_dat_oB[3:0] ;
          end
      end
  end

always @( posedge clkC )
  begin
    if (rstC==1'b1)
      begin
        controlC[RB_CTRL_EN]  <= 0;
        abs_time_cntrC <= 0;
      end
    else
      begin
        abs_time_cntrC <= abs_time_cntrC+1;
        if ((wb_adr_oC[WB_ADDR_WIDTH-1:RMH+1] ==0)&&(wb_adr_oC[RMH:RML] ==RM_CTRL)&&(wb_adr_oC[RAH:RAL] ==RA_CTRL)&&wb_weC&&wb_stbC)
          begin
            controlC <= wb_dat_oC[3:0] ;
          end
      end
  end

always @( posedge clkA )
  begin
    if ((wb_adr_oA[WB_ADDR_WIDTH-1:RMH+1] ==0)&&(wb_adr_oA[RMH:RML] ==RM_CTRL)&&(wb_adr_oA[RAH:RAL] ==RA_SS_DELAY)&&wb_weA&&wb_stbA)
      begin
        ss_delayA <= wb_dat_oA[RF_SS_DELAY+:RF_SS_DELAY_WIDTH] ;
      end
    if ((wb_adr_oA[WB_ADDR_WIDTH-1:RMH+1] ==0)&&(wb_adr_oA[RMH:RML] ==RM_THRESH)&&wb_weA&&wb_stbA)
      begin
        case (wb_adr_oA[RAH:RAL] )
          4'b0000 : thresholdsA[3'd0]  <= wb_dat_oA;
          4'b0001 : thresholdsA[3'd1]  <= wb_dat_oA;
          4'b0010 : thresholdsA[3'd2]  <= wb_dat_oA;
          4'b0011 : thresholdsA[3'd3]  <= wb_dat_oA;
          4'b0100 : thresholdsA[3'd4]  <= wb_dat_oA;
          4'b0101 : thresholdsA[3'd5]  <= wb_dat_oA;
          default : thresholdsA[3'd0]  <= wb_dat_oA;
        endcase
      end
    if ((wb_adr_oA[WB_ADDR_WIDTH-1:RMH+1] ==0)&&(wb_adr_oA[RMH:RML] ==RM_COEF)&&wb_weA&&wb_stbA)
      begin
        case (wb_adr_oA[RAH:RAL] )
          4'b0000 : coeffA[4'd0]  <= wb_dat_oA;
          4'b0001 : coeffA[4'd1]  <= wb_dat_oA;
          4'b0010 : coeffA[4'd2]  <= wb_dat_oA;
          4'b0011 : coeffA[4'd3]  <= wb_dat_oA;
          4'b0100 : coeffA[4'd4]  <= wb_dat_oA;
          4'b0101 : coeffA[4'd5]  <= wb_dat_oA;
          4'b0110 : coeffA[4'd6]  <= wb_dat_oA;
          4'b0111 : coeffA[4'd7]  <= wb_dat_oA;
          4'b1000 : coeffA[4'd8]  <= wb_dat_oA;
          4'b1001 : coeffA[4'd9]  <= wb_dat_oA;
          default : coeffA[4'd0]  <= wb_dat_oA;
        endcase
      end
  end

always @( posedge clkB )
  begin
    if ((wb_adr_oB[WB_ADDR_WIDTH-1:RMH+1] ==0)&&(wb_adr_oB[RMH:RML] ==RM_CTRL)&&(wb_adr_oB[RAH:RAL] ==RA_SS_DELAY)&&wb_weB&&wb_stbB)
      begin
        ss_delayB <= wb_dat_oB[RF_SS_DELAY+:RF_SS_DELAY_WIDTH] ;
      end
    if ((wb_adr_oB[WB_ADDR_WIDTH-1:RMH+1] ==0)&&(wb_adr_oB[RMH:RML] ==RM_THRESH)&&wb_weB&&wb_stbB)
      begin
        case (wb_adr_oB[RAH:RAL] )
          4'b0000 : thresholdsB[3'd0]  <= wb_dat_oB;
          4'b0001 : thresholdsB[3'd1]  <= wb_dat_oB;
          4'b0010 : thresholdsB[3'd2]  <= wb_dat_oB;
          4'b0011 : thresholdsB[3'd3]  <= wb_dat_oB;
          4'b0100 : thresholdsB[3'd4]  <= wb_dat_oB;
          4'b0101 : thresholdsB[3'd5]  <= wb_dat_oB;
          default : thresholdsB[3'd0]  <= wb_dat_oB;
        endcase
      end
    if ((wb_adr_oB[WB_ADDR_WIDTH-1:RMH+1] ==0)&&(wb_adr_oB[RMH:RML] ==RM_COEF)&&wb_weB&&wb_stbB)
      begin
        case (wb_adr_oB[RAH:RAL] )
          4'b0000 : coeffB[4'd0]  <= wb_dat_oB;
          4'b0001 : coeffB[4'd1]  <= wb_dat_oB;
          4'b0010 : coeffB[4'd2]  <= wb_dat_oB;
          4'b0011 : coeffB[4'd3]  <= wb_dat_oB;
          4'b0100 : coeffB[4'd4]  <= wb_dat_oB;
          4'b0101 : coeffB[4'd5]  <= wb_dat_oB;
          4'b0110 : coeffB[4'd6]  <= wb_dat_oB;
          4'b0111 : coeffB[4'd7]  <= wb_dat_oB;
          4'b1000 : coeffB[4'd8]  <= wb_dat_oB;
          4'b1001 : coeffB[4'd9]  <= wb_dat_oB;
          default : coeffB[4'd0]  <= wb_dat_oB;
        endcase
      end
  end

always @( posedge clkC )
  begin
    if ((wb_adr_oC[WB_ADDR_WIDTH-1:RMH+1] ==0)&&(wb_adr_oC[RMH:RML] ==RM_CTRL)&&(wb_adr_oC[RAH:RAL] ==RA_SS_DELAY)&&wb_weC&&wb_stbC)
      begin
        ss_delayC <= wb_dat_oC[RF_SS_DELAY+:RF_SS_DELAY_WIDTH] ;
      end
    if ((wb_adr_oC[WB_ADDR_WIDTH-1:RMH+1] ==0)&&(wb_adr_oC[RMH:RML] ==RM_THRESH)&&wb_weC&&wb_stbC)
      begin
        case (wb_adr_oC[RAH:RAL] )
          4'b0000 : thresholdsC[3'd0]  <= wb_dat_oC;
          4'b0001 : thresholdsC[3'd1]  <= wb_dat_oC;
          4'b0010 : thresholdsC[3'd2]  <= wb_dat_oC;
          4'b0011 : thresholdsC[3'd3]  <= wb_dat_oC;
          4'b0100 : thresholdsC[3'd4]  <= wb_dat_oC;
          4'b0101 : thresholdsC[3'd5]  <= wb_dat_oC;
          default : thresholdsC[3'd0]  <= wb_dat_oC;
        endcase
      end
    if ((wb_adr_oC[WB_ADDR_WIDTH-1:RMH+1] ==0)&&(wb_adr_oC[RMH:RML] ==RM_COEF)&&wb_weC&&wb_stbC)
      begin
        case (wb_adr_oC[RAH:RAL] )
          4'b0000 : coeffC[4'd0]  <= wb_dat_oC;
          4'b0001 : coeffC[4'd1]  <= wb_dat_oC;
          4'b0010 : coeffC[4'd2]  <= wb_dat_oC;
          4'b0011 : coeffC[4'd3]  <= wb_dat_oC;
          4'b0100 : coeffC[4'd4]  <= wb_dat_oC;
          4'b0101 : coeffC[4'd5]  <= wb_dat_oC;
          4'b0110 : coeffC[4'd6]  <= wb_dat_oC;
          4'b0111 : coeffC[4'd7]  <= wb_dat_oC;
          4'b1000 : coeffC[4'd8]  <= wb_dat_oC;
          4'b1001 : coeffC[4'd9]  <= wb_dat_oC;
          default : coeffC[4'd0]  <= wb_dat_oC;
        endcase
      end
  end

always @( posedge clk )
  begin
    wb_dat_i <= wb_dat_i_mux;
  end
integer tap1;
integer th1;

always @*
  begin
    for(tap1 =  0;tap1<NUM_TAPS;tap1 =  tap1+1)
      begin
        if (wb_adr_o[RAH:RAL] ==tap1[3:0] )
          begin
            coeff_readback =  coeff[tap1] ;
          end
      end
    for(th1 =  0;th1<6;th1 =  th1+1)
      begin
        if (wb_adr_o[RAH:RAL] ==th1[3:0] )
          begin
            thresholds_readback =  thresholds[th1] ;
          end
      end
    case (wb_adr_o[RMH:RML] )
      3'b000 : wb_dat_i_mux =  coeff_readback;
      3'b001 : wb_dat_i_mux =  thresholds_readback;
      3'b010 : wb_dat_i_mux =  (wb_adr_o[RAH:RAL] ==RA_CTRL) ? {12'b0,control[3:0] } : {ZEROS[0+:WB_DATA_WIDTH-RF_SS_DELAY_WIDTH] ,ss_delay};
      default : wb_dat_i_mux =  coeff_readback;
    endcase
  end

generate
genvar gentap;

  for(gentap =  0;gentap<NUM_TAPS;gentap =  gentap+1)
    begin : gen_fir 

      mult_reg#(.IN0_WIDTH(SAMPLE_WIDTH), .IN1_WIDTH(COEF_WIDTH)) mult_reg (
          .clk_i(clk),
          .in0_i(samples[NUM_TAPS-gentap-1] ),
          .in1_i(coeff[gentap] ),
          .product_o(products[gentap] )
          );
    end

endgenerate
integer b;

always @*
  begin
    for(b =  0;b<10;b =  b+1)
      begin
        products_1d[(PRODUCT_WIDTH*b)+:PRODUCT_WIDTH]  =  products[b] ;
      end
  end

adder_tree10#(.DATA_WIDTH(PRODUCT_WIDTH)) adder_tree10 (
    .clk(clk),
    .in0(products[0] ),
    .in1(products[1] ),
    .in2(products[2] ),
    .in3(products[3] ),
    .in4(products[4] ),
    .in5(products[5] ),
    .in6(products[6] ),
    .in7(products[7] ),
    .in8(products[8] ),
    .in9(products[9] ),
    .sum(fir_out)
    );
assign threshold_hi =  {thresholds[2] [3:0] ,thresholds[1] ,thresholds[0] };
assign threshold_lo =  {thresholds[5] [3:0] ,thresholds[4] ,thresholds[3] };
assign fir_out_gte_thresh_hi =  (fir_out>=threshold_hi);
assign fir_out_lte_thresh_lo =  (fir_out<=threshold_lo);
assign fir_out_gt_ss_fir_out =  (fir_out>ss_fir_out);
assign fir_out_lt_ss_fir_out =  (fir_out<ss_fir_out);
assign abs_fir_out =  fir_out[(PRODUCT_WIDTH+$clog2(NUM_TAPS))-1]  ? - fir_out  : fir_out;
assign ss_load_en_hi =  fir_out_gte_thresh_hi&(~ ss_buff_valid | ( fir_out_gt_ss_fir_out&control[RB_REPLACE_MORE_POS]  ) );
assign ss_load_en_lo =  fir_out_lte_thresh_lo&(~ ss_buff_valid | ( fir_out_lt_ss_fir_out&control[RB_REPLACE_MORE_NEG]  ) );
assign ss_load_en_mag =  (fir_out_gte_thresh_hi|fir_out_lte_thresh_lo)&(abs_fir_out>ss_fir_out)&control[RB_REPLACE_LARGE_MAG] ;
assign ss_load_en =  ss_load_en_hi|ss_load_en_lo|ss_load_en_mag;
integer o;

always @( posedge clk )
  begin
    if (rst==1'b1)
      begin
        ss_fir_out <= 0;
      end
    else
      begin
        if (ss_load_en&&(~ ss_buff_valid || ( ss_tx_idle&&(ss_delay_cntr==0) ) ))
          begin
            ss_delay_cntr <= ss_delay;
          end
        else
          if (ss_delay_cntr!=0)
            begin
              ss_delay_cntr <= ss_delay_cntr-1;
            end
        if (ss_load_en)
          begin
            if (control[RB_REPLACE_LARGE_MAG] )
              ss_fir_out <= abs_fir_out;
            else
              ss_fir_out <= fir_out;
            ss_buff[31:0]  <= abs_time_cntr;
            for(o =  0;o<NUM_TAPS;o =  o+1)
              begin
                ss_buff[(ABS_TIME_WIDTH+o*SAMPLE_WIDTH)+:SAMPLE_WIDTH]  <= samples[o+1+$clog2(NUM_TAPS)] ;
              end
          end
      end
  end

always @( posedge clkA )
  begin
    if (rstA==1'b1)
      begin
        ss_buff_validA <= 1'b0;
      end
    else
      begin
        if (controlA[RB_CTRL_EN] )
          begin
            ss_buff_validA <= ss_load_enA|(ss_buff_validA&(~ ss_tx_idleA | ( ss_delay_cntrA!=0 ) ));
          end
      end
  end

always @( posedge clkB )
  begin
    if (rstB==1'b1)
      begin
        ss_buff_validB <= 1'b0;
      end
    else
      begin
        if (controlB[RB_CTRL_EN] )
          begin
            ss_buff_validB <= ss_load_enB|(ss_buff_validB&(~ ss_tx_idleB | ( ss_delay_cntrB!=0 ) ));
          end
      end
  end

always @( posedge clkC )
  begin
    if (rstC==1'b1)
      begin
        ss_buff_validC <= 1'b0;
      end
    else
      begin
        if (controlC[RB_CTRL_EN] )
          begin
            ss_buff_validC <= ss_load_enC|(ss_buff_validC&(~ ss_tx_idleC | ( ss_delay_cntrC!=0 ) ));
          end
      end
  end
assign ss_tx_start =  ss_buff_valid&(ss_delay_cntr==0);

snapshot_txTMR #(.SAMPLE_WIDTH(SAMPLE_WIDTH), .COEF_WIDTH(COEF_WIDTH), .NUM_TAPS(NUM_TAPS), .ABS_TIME_WIDTH(ABS_TIME_WIDTH), .RF_SS_DELAY_WIDTH(RF_SS_DELAY_WIDTH), .SS_BUFF_SZ(SS_BUFF_SZ)) snapshot_tx_0 (
    .clk(clk),
    .rst(rst),
    .ss_tx_start(ss_tx_start),
    .ss_buff(ss_buff),
    .idle(ss_tx_idle),
    .pdw_data(pdw_data),
    .pdw_frame(pdw_frame)
    );

i2c_target_wbmTMR #(.WB_DATA_WIDTH(WB_DATA_WIDTH), .WB_ADDR_WIDTH(WB_ADDR_WIDTH), .WB_SELECT_WIDTH(WB_SELECT_WIDTH)) i2c_target_wbmTMR_0 (
    .clk(clk),
    .rst(rst),
    .i2c_scl_i(i2c_scl_i),
    .i2c_scl_o(i2c_scl_o),
    .i2c_scl_t(i2c_scl_t),
    .i2c_sda_i(i2c_sda_i),
    .i2c_sda_o(i2c_sda_o),
    .i2c_sda_t(i2c_sda_t),
    .wb_adr_o(wb_adr_o),
    .wb_dat_i(wb_dat_i),
    .wb_dat_o(wb_dat_o),
    .wb_we_o(wb_we),
    .wb_sel_o(wb_sel),
    .wb_stb_o(wb_stb),
    .wb_ack_i(wb_ack),
    .wb_err_i(1'b0),
    .wb_cyc_o(wb_cyc),
    .busy(busy),
    .bus_addressed(bus_addressed),
    .bus_active(bus_active),
    .enable(1'b1),
    .device_address(I2C_ADDR)
    );
`ifdef  COCOTB_SIM
integer j;
integer k;
integer l;
integer m;
initial
  begin
    $dumpfile("fir_top_i2c_tmr.lxt2");
    $dumpvars;
    for(m =  0;m<NUM_TAPS;m =  m+1)
      $dumpvars(0, products[m] );
    for(j =  0;j<SAMPLE_BUFFER_SZ;j =  j+1)
      $dumpvars(0, samples[j] );
    for(k =  0;k<NUM_TAPS;k =  k+1)
      $dumpvars(0, coeff[k] );
    for(l =  0;l<6;l =  l+1)
      $dumpvars(0, thresholds[l] );
  end
`endif   

majorityVoter #(.WIDTH(((ABS_TIME_WIDTH-1)>(0)) ? ((ABS_TIME_WIDTH-1)-(0)+1) : ((0)-(ABS_TIME_WIDTH-1)+1))) abs_time_cntrVoter (
    .inA(abs_time_cntrA),
    .inB(abs_time_cntrB),
    .inC(abs_time_cntrC),
    .out(abs_time_cntr),
    .tmrErr(abs_time_cntrTmrError)
    );
genvar gen_coeffVoter;

generate
  for(gen_coeffVoter =  ((0>9) ? 9 : 0);gen_coeffVoter<=((0>9) ? 0 : 9);gen_coeffVoter =  gen_coeffVoter+1)
    begin : gen_coeffVoter_fanout 

      majorityVoter #(.WIDTH(((COEF_WIDTH-1)>(0)) ? ((COEF_WIDTH-1)-(0)+1) : ((0)-(COEF_WIDTH-1)+1))) coeffVoter (
          .inA(coeffA[gen_coeffVoter] ),
          .inB(coeffB[gen_coeffVoter] ),
          .inC(coeffC[gen_coeffVoter] ),
          .out(coeff[gen_coeffVoter] ),
          .tmrErr()
          );
    end

endgenerate

majorityVoter #(.WIDTH(4)) controlVoter (
    .inA(controlA),
    .inB(controlB),
    .inC(controlC),
    .out(control),
    .tmrErr(controlTmrError)
    );

majorityVoter ss_buff_validVoter (
    .inA(ss_buff_validA),
    .inB(ss_buff_validB),
    .inC(ss_buff_validC),
    .out(ss_buff_valid),
    .tmrErr(ss_buff_validTmrError)
    );

majorityVoter #(.WIDTH(((RF_SS_DELAY_WIDTH-1)>(0)) ? ((RF_SS_DELAY_WIDTH-1)-(0)+1) : ((0)-(RF_SS_DELAY_WIDTH-1)+1))) ss_delayVoter (
    .inA(ss_delayA),
    .inB(ss_delayB),
    .inC(ss_delayC),
    .out(ss_delay),
    .tmrErr(ss_delayTmrError)
    );
genvar gen_thresholdsVoter;

generate
  for(gen_thresholdsVoter =  ((5>0) ? 0 : 5);gen_thresholdsVoter<=((5>0) ? 5 : 0);gen_thresholdsVoter =  gen_thresholdsVoter+1)
    begin : gen_thresholdsVoter_fanout 

      majorityVoter #(.WIDTH(16)) thresholdsVoter (
          .inA(thresholdsA[gen_thresholdsVoter] ),
          .inB(thresholdsB[gen_thresholdsVoter] ),
          .inC(thresholdsC[gen_thresholdsVoter] ),
          .out(thresholds[gen_thresholdsVoter] ),
          .tmrErr()
          );
    end

endgenerate

fanout clkFanout (
    .in(clk),
    .outA(clkA),
    .outB(clkB),
    .outC(clkC)
    );

fanout rstFanout (
    .in(rst),
    .outA(rstA),
    .outB(rstB),
    .outC(rstC)
    );

fanout #(.WIDTH(((RF_SS_DELAY_WIDTH-1)>(0)) ? ((RF_SS_DELAY_WIDTH-1)-(0)+1) : ((0)-(RF_SS_DELAY_WIDTH-1)+1))) ss_delay_cntrFanout (
    .in(ss_delay_cntr),
    .outA(ss_delay_cntrA),
    .outB(ss_delay_cntrB),
    .outC(ss_delay_cntrC)
    );

fanout ss_load_enFanout (
    .in(ss_load_en),
    .outA(ss_load_enA),
    .outB(ss_load_enB),
    .outC(ss_load_enC)
    );

fanout ss_tx_idleFanout (
    .in(ss_tx_idle),
    .outA(ss_tx_idleA),
    .outB(ss_tx_idleB),
    .outC(ss_tx_idleC)
    );

fanout #(.WIDTH(((WB_ADDR_WIDTH-1)>(0)) ? ((WB_ADDR_WIDTH-1)-(0)+1) : ((0)-(WB_ADDR_WIDTH-1)+1))) wb_adr_oFanout (
    .in(wb_adr_o),
    .outA(wb_adr_oA),
    .outB(wb_adr_oB),
    .outC(wb_adr_oC)
    );

fanout #(.WIDTH(((WB_DATA_WIDTH-1)>(0)) ? ((WB_DATA_WIDTH-1)-(0)+1) : ((0)-(WB_DATA_WIDTH-1)+1))) wb_dat_oFanout (
    .in(wb_dat_o),
    .outA(wb_dat_oA),
    .outB(wb_dat_oB),
    .outC(wb_dat_oC)
    );

fanout wb_stbFanout (
    .in(wb_stb),
    .outA(wb_stbA),
    .outB(wb_stbB),
    .outC(wb_stbC)
    );

fanout wb_weFanout (
    .in(wb_we),
    .outA(wb_weA),
    .outB(wb_weB),
    .outC(wb_weC)
    );
endmodule

`default_nettype  wire
