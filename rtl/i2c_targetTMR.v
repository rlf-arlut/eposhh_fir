// SPDX-FileCopyrightText: 2023 Board of Regents, The University of Texas System
// SPDX-FileAttributionText: <text>This software was developed with government support under Grant no. DE-SC0023055 awarded by the Department of Energy. The government has certain rights in the copyright.</text>
//
// SPDX-License-Identifier: BSD-3-Clause

/****************************************************************************************************
 *                          ! THIS FILE WAS AUTO-GENERATED BY TMRG TOOL !                           *
 *                                   ! DO NOT EDIT IT MANUALLY !                                    *
 *                                                                                                  *
 * file    : ./i2c_targetTMR.v                                                                      *
 *                                                                                                  *
 * user    : rfriesen                                                                               *
 * host    : sgl-lap054                                                                             *
 * date    : 11/09/2023 16:08:18                                                                    *
 *                                                                                                  *
 * workdir : /home/rfriesen/git/eposhh_fir5tap/rtl                                                  *
 * cmd     : /home/rfriesen/git/tmrg/bin/tmrg -v -c fir_top_i2c_tmr.cnf --no-common-definitions     *
 *           --generate-report fir_top_i2c_tmr.v adder_tree10.v crc16TMR.v snapshot_txTMR.v         *
 *           i2c_target.v i2c_target_wbc.v snapshot_txTMR.v mult_reg.v voter.v fanout.v             *
 * tmrg rev: 6574161d3b316703ff7c8948d3a894c6005f77d4                                               *
 *                                                                                                  *
 * src file: i2c_target.v                                                                           *
 *           Git SHA           : f952ba4289b6e09faf0e42a1ff4faddf2935b3fd                           *
 *           Modification time : 2023-09-11 15:48:53.158158                                         *
 *           File Size         : 18622                                                              *
 *           MD5 hash          : c7bfaa4985124e1fe8e0e328d0176e48                                   *
 *                                                                                                  *
 ****************************************************************************************************/

module i2c_targetTMR #(
  parameter  FILTER_LEN  = 4
)(
  input wire  clk ,
  input wire  rst ,
  input wire  release_busA ,
  input wire  release_busB ,
  input wire  release_busC ,
  input wire [7:0] s_axis_data_tdataA ,
  input wire [7:0] s_axis_data_tdataB ,
  input wire [7:0] s_axis_data_tdataC ,
  input wire  s_axis_data_tvalidA ,
  input wire  s_axis_data_tvalidB ,
  input wire  s_axis_data_tvalidC ,
  output wire  s_axis_data_treadyA ,
  output wire  s_axis_data_treadyB ,
  output wire  s_axis_data_treadyC ,
  input wire  s_axis_data_tlastA ,
  input wire  s_axis_data_tlastB ,
  input wire  s_axis_data_tlastC ,
  output wire [7:0] m_axis_data_tdataA ,
  output wire [7:0] m_axis_data_tdataB ,
  output wire [7:0] m_axis_data_tdataC ,
  output wire  m_axis_data_tvalidA ,
  output wire  m_axis_data_tvalidB ,
  output wire  m_axis_data_tvalidC ,
  input wire  m_axis_data_treadyA ,
  input wire  m_axis_data_treadyB ,
  input wire  m_axis_data_treadyC ,
  output wire  m_axis_data_tlastA ,
  output wire  m_axis_data_tlastB ,
  output wire  m_axis_data_tlastC ,
  input wire  scl_iA ,
  input wire  scl_iB ,
  input wire  scl_iC ,
  output wire  scl_oA ,
  output wire  scl_oB ,
  output wire  scl_oC ,
  output wire  scl_tA ,
  output wire  scl_tB ,
  output wire  scl_tC ,
  input wire  sda_iA ,
  input wire  sda_iB ,
  input wire  sda_iC ,
  output wire  sda_oA ,
  output wire  sda_oB ,
  output wire  sda_oC ,
  output wire  sda_tA ,
  output wire  sda_tB ,
  output wire  sda_tC ,
  output wire  busyA ,
  output wire  busyB ,
  output wire  busyC ,
  output wire [6:0] bus_addressA ,
  output wire [6:0] bus_addressB ,
  output wire [6:0] bus_addressC ,
  output wire  bus_addressedA ,
  output wire  bus_addressedB ,
  output wire  bus_addressedC ,
  output wire  bus_activeA ,
  output wire  bus_activeB ,
  output wire  bus_activeC ,
  input wire  enableA ,
  input wire  enableB ,
  input wire  enableC ,
  input wire [6:0] device_addressA ,
  input wire [6:0] device_addressB ,
  input wire [6:0] device_addressC ,
  input wire [6:0] device_address_maskA ,
  input wire [6:0] device_address_maskB ,
  input wire [6:0] device_address_maskC 
);
localparam [4:0] STATE_IDLE =4'd0;
localparam [4:0] STATE_ADDRESS =4'd1;
localparam [4:0] STATE_ACK =4'd2;
localparam [4:0] STATE_WRITE_1 =4'd3;
localparam [4:0] STATE_WRITE_2 =4'd4;
localparam [4:0] STATE_READ_1 =4'd5;
localparam [4:0] STATE_READ_2 =4'd6;
localparam [4:0] STATE_READ_3 =4'd7;
wire rstC;
wire rstB;
wire rstA;
wire clkC;
wire clkB;
wire clkA;
wire sda_i_regTmrError;
wire sda_i_reg;
wire scl_i_regTmrError;
wire scl_i_reg;
wire last_sda_i_regTmrError;
wire last_sda_i_reg;
wire last_scl_i_regTmrError;
wire last_scl_i_reg;
reg  [4:0] state_regA ;
reg  [4:0] state_nextA ;
reg  [4:0] state_regB ;
reg  [4:0] state_nextB ;
reg  [4:0] state_regC ;
reg  [4:0] state_nextC ;
reg  [6:0] addr_regA ;
reg  [6:0] addr_nextA ;
reg  [6:0] addr_regB ;
reg  [6:0] addr_nextB ;
reg  [6:0] addr_regC ;
reg  [6:0] addr_nextC ;
reg  [7:0] data_regA ;
reg  [7:0] data_nextA ;
reg  [7:0] data_regB ;
reg  [7:0] data_nextB ;
reg  [7:0] data_regC ;
reg  [7:0] data_nextC ;
reg  data_valid_regA ;
reg  data_valid_nextA ;
reg  data_valid_regB ;
reg  data_valid_nextB ;
reg  data_valid_regC ;
reg  data_valid_nextC ;
reg  data_out_reg_valid_regA ;
reg  data_out_reg_valid_nextA ;
reg  data_out_reg_valid_regB ;
reg  data_out_reg_valid_nextB ;
reg  data_out_reg_valid_regC ;
reg  data_out_reg_valid_nextC ;
reg  last_regA ;
reg  last_nextA ;
reg  last_regB ;
reg  last_nextB ;
reg  last_regC ;
reg  last_nextC ;
reg  mode_read_regA ;
reg  mode_read_nextA ;
reg  mode_read_regB ;
reg  mode_read_nextB ;
reg  mode_read_regC ;
reg  mode_read_nextC ;
reg  [3:0] bit_count_regA ;
reg  [3:0] bit_count_nextA ;
reg  [3:0] bit_count_regB ;
reg  [3:0] bit_count_nextB ;
reg  [3:0] bit_count_regC ;
reg  [3:0] bit_count_nextC ;
reg  s_axis_data_tready_regA ;
reg  s_axis_data_tready_nextA ;
reg  s_axis_data_tready_regB ;
reg  s_axis_data_tready_nextB ;
reg  s_axis_data_tready_regC ;
reg  s_axis_data_tready_nextC ;
reg  [7:0] m_axis_data_tdata_regA ;
reg  [7:0] m_axis_data_tdata_nextA ;
reg  [7:0] m_axis_data_tdata_regB ;
reg  [7:0] m_axis_data_tdata_nextB ;
reg  [7:0] m_axis_data_tdata_regC ;
reg  [7:0] m_axis_data_tdata_nextC ;
reg  m_axis_data_tvalid_regA ;
reg  m_axis_data_tvalid_nextA ;
reg  m_axis_data_tvalid_regB ;
reg  m_axis_data_tvalid_nextB ;
reg  m_axis_data_tvalid_regC ;
reg  m_axis_data_tvalid_nextC ;
reg  m_axis_data_tlast_regA ;
reg  m_axis_data_tlast_nextA ;
reg  m_axis_data_tlast_regB ;
reg  m_axis_data_tlast_nextB ;
reg  m_axis_data_tlast_regC ;
reg  m_axis_data_tlast_nextC ;
reg  [FILTER_LEN-1:0] scl_i_filterA ;
reg  [FILTER_LEN-1:0] scl_i_filterB ;
reg  [FILTER_LEN-1:0] scl_i_filterC ;
reg  [FILTER_LEN-1:0] sda_i_filterA ;
reg  [FILTER_LEN-1:0] sda_i_filterB ;
reg  [FILTER_LEN-1:0] sda_i_filterC ;
reg  scl_i_regA ;
reg  scl_i_regB ;
reg  scl_i_regC ;
reg  sda_i_regA ;
reg  sda_i_regB ;
reg  sda_i_regC ;
reg  scl_o_regA ;
reg  scl_o_nextA ;
reg  scl_o_regB ;
reg  scl_o_nextB ;
reg  scl_o_regC ;
reg  scl_o_nextC ;
reg  sda_o_regA ;
reg  sda_o_nextA ;
reg  sda_o_regB ;
reg  sda_o_nextB ;
reg  sda_o_regC ;
reg  sda_o_nextC ;
reg  last_scl_i_regA ;
reg  last_scl_i_regB ;
reg  last_scl_i_regC ;
reg  last_sda_i_regA ;
reg  last_sda_i_regB ;
reg  last_sda_i_regC ;
reg  busy_regA ;
reg  busy_regB ;
reg  busy_regC ;
reg  bus_active_regA ;
reg  bus_active_regB ;
reg  bus_active_regC ;
reg  bus_addressed_regA ;
reg  bus_addressed_nextA ;
reg  bus_addressed_regB ;
reg  bus_addressed_nextB ;
reg  bus_addressed_regC ;
reg  bus_addressed_nextC ;
assign bus_addressA =  addr_regA;
assign bus_addressB =  addr_regB;
assign bus_addressC =  addr_regC;
assign s_axis_data_treadyA =  s_axis_data_tready_regA;
assign s_axis_data_treadyB =  s_axis_data_tready_regB;
assign s_axis_data_treadyC =  s_axis_data_tready_regC;
assign m_axis_data_tdataA =  m_axis_data_tdata_regA;
assign m_axis_data_tdataB =  m_axis_data_tdata_regB;
assign m_axis_data_tdataC =  m_axis_data_tdata_regC;
assign m_axis_data_tvalidA =  m_axis_data_tvalid_regA;
assign m_axis_data_tvalidB =  m_axis_data_tvalid_regB;
assign m_axis_data_tvalidC =  m_axis_data_tvalid_regC;
assign m_axis_data_tlastA =  m_axis_data_tlast_regA;
assign m_axis_data_tlastB =  m_axis_data_tlast_regB;
assign m_axis_data_tlastC =  m_axis_data_tlast_regC;
assign scl_oA =  scl_o_regA;
assign scl_oB =  scl_o_regB;
assign scl_oC =  scl_o_regC;
assign scl_tA =  scl_o_regA;
assign scl_tB =  scl_o_regB;
assign scl_tC =  scl_o_regC;
assign sda_oA =  sda_o_regA;
assign sda_oB =  sda_o_regB;
assign sda_oC =  sda_o_regC;
assign sda_tA =  sda_o_regA;
assign sda_tB =  sda_o_regB;
assign sda_tC =  sda_o_regC;
assign busyA =  busy_regA;
assign busyB =  busy_regB;
assign busyC =  busy_regC;
assign bus_activeA =  bus_active_regA;
assign bus_activeB =  bus_active_regB;
assign bus_activeC =  bus_active_regC;
assign bus_addressedA =  bus_addressed_regA;
assign bus_addressedB =  bus_addressed_regB;
assign bus_addressedC =  bus_addressed_regC;
assign scl_posedge =  scl_i_reg&&!last_scl_i_reg;
assign scl_negedge =  !scl_i_reg&&last_scl_i_reg;
assign sda_posedge =  sda_i_reg&&!last_sda_i_reg;
assign sda_negedge =  !sda_i_reg&&last_sda_i_reg;
assign start_bit =  sda_negedge&&scl_i_reg;
assign stop_bit =  sda_posedge&&scl_i_reg;

always @*
  begin
    state_nextA =  STATE_IDLE;
    addr_nextA =  addr_regA;
    data_nextA =  data_regA;
    data_valid_nextA =  data_valid_regA;
    data_out_reg_valid_nextA =  data_out_reg_valid_regA;
    last_nextA =  last_regA;
    mode_read_nextA =  mode_read_regA;
    bit_count_nextA =  bit_count_regA;
    s_axis_data_tready_nextA =  1'b0;
    m_axis_data_tdata_nextA =  m_axis_data_tdata_regA;
    m_axis_data_tvalid_nextA =  m_axis_data_tvalid_regA&&!m_axis_data_treadyA;
    m_axis_data_tlast_nextA =  m_axis_data_tlast_regA;
    scl_o_nextA =  scl_o_regA;
    sda_o_nextA =  sda_o_regA;
    bus_addressed_nextA =  bus_addressed_regA;
    if (start_bit)
      begin
        data_valid_nextA =  1'b0;
        data_out_reg_valid_nextA =  1'b0;
        bit_count_nextA =  4'd7;
        m_axis_data_tlast_nextA =  1'b1;
        m_axis_data_tvalid_nextA =  data_out_reg_valid_regA;
        bus_addressed_nextA =  1'b0;
        state_nextA =  STATE_ADDRESS;
      end
    else
      if (release_busA||stop_bit)
        begin
          data_valid_nextA =  1'b0;
          data_out_reg_valid_nextA =  1'b0;
          m_axis_data_tlast_nextA =  1'b1;
          m_axis_data_tvalid_nextA =  data_out_reg_valid_regA;
          bus_addressed_nextA =  1'b0;
          state_nextA =  STATE_IDLE;
        end
      else
        begin
          case (state_regA)
            STATE_IDLE : 
              begin
                data_valid_nextA =  1'b0;
                data_out_reg_valid_nextA =  1'b0;
                bus_addressed_nextA =  1'b0;
                state_nextA =  STATE_IDLE;
              end
            STATE_ADDRESS : 
              begin
                if (scl_posedge)
                  begin
                    if (bit_count_regA>0)
                      begin
                        bit_count_nextA =  bit_count_regA-1;
                        data_nextA =  {data_regA[6:0] ,sda_i_regA};
                        state_nextA =  STATE_ADDRESS;
                      end
                    else
                      begin
                        if (enableA&&(device_addressA&device_address_maskA)==(data_regA[6:0] &device_address_maskA))
                          begin
                            addr_nextA =  data_regA[6:0] ;
                            mode_read_nextA =  sda_i_regA;
                            bus_addressed_nextA =  1'b1;
                            state_nextA =  STATE_ACK;
                          end
                        else
                          begin
                            state_nextA =  STATE_IDLE;
                          end
                      end
                  end
                else
                  begin
                    state_nextA =  STATE_ADDRESS;
                  end
              end
            STATE_ACK : 
              begin
                if (scl_negedge)
                  begin
                    sda_o_nextA =  1'b0;
                    bit_count_nextA =  4'd7;
                    if (mode_read_regA)
                      begin
                        s_axis_data_tready_nextA =  1'b1;
                        data_valid_nextA =  1'b0;
                        state_nextA =  STATE_READ_1;
                      end
                    else
                      begin
                        state_nextA =  STATE_WRITE_1;
                      end
                  end
                else
                  begin
                    state_nextA =  STATE_ACK;
                  end
              end
            STATE_WRITE_1 : 
              begin
                if (scl_negedge||!scl_o_regA)
                  begin
                    sda_o_nextA =  1'b1;
                    if (m_axis_data_tvalidA&&!m_axis_data_treadyA)
                      begin
                        scl_o_nextA =  1'b0;
                        state_nextA =  STATE_WRITE_1;
                      end
                    else
                      begin
                        scl_o_nextA =  1'b1;
                        if (data_valid_regA)
                          begin
                            m_axis_data_tdata_nextA =  data_regA;
                            m_axis_data_tlast_nextA =  1'b0;
                          end
                        data_valid_nextA =  1'b0;
                        data_out_reg_valid_nextA =  data_valid_regA;
                        state_nextA =  STATE_WRITE_2;
                      end
                  end
                else
                  begin
                    state_nextA =  STATE_WRITE_1;
                  end
              end
            STATE_WRITE_2 : 
              begin
                if (scl_posedge)
                  begin
                    data_nextA =  {data_regA[6:0] ,sda_i_regA};
                    if (bit_count_regA>0)
                      begin
                        bit_count_nextA =  bit_count_regA-1;
                        state_nextA =  STATE_WRITE_2;
                      end
                    else
                      begin
                        m_axis_data_tvalid_nextA =  data_out_reg_valid_regA;
                        data_out_reg_valid_nextA =  1'b0;
                        data_valid_nextA =  1'b1;
                        state_nextA =  STATE_ACK;
                      end
                  end
                else
                  begin
                    state_nextA =  STATE_WRITE_2;
                  end
              end
            STATE_READ_1 : 
              begin
                if (s_axis_data_treadyA&&s_axis_data_tvalidA)
                  begin
                    s_axis_data_tready_nextA =  1'b0;
                    data_nextA =  s_axis_data_tdataA;
                    data_valid_nextA =  1'b1;
                  end
                else
                  begin
                    s_axis_data_tready_nextA =  !data_valid_regA;
                  end
                if (scl_negedge||!scl_o_regA)
                  begin
                    if (!data_valid_regA)
                      begin
                        scl_o_nextA =  1'b0;
                        state_nextA =  STATE_READ_1;
                      end
                    else
                      begin
                        scl_o_nextA =  1'b1;
                        sda_o_nextA =  data_regA[7] ;
                        data_nextA =  {data_regA[6:0] ,1'b0};
                        if (bit_count_regA>0)
                          begin
                            bit_count_nextA =  bit_count_regA-1;
                            state_nextA =  STATE_READ_1;
                          end
                        else
                          begin
                            state_nextA =  STATE_READ_2;
                          end
                      end
                  end
                else
                  begin
                    state_nextA =  STATE_READ_1;
                  end
              end
            STATE_READ_2 : 
              begin
                if (scl_negedge)
                  begin
                    sda_o_nextA =  1'b1;
                    state_nextA =  STATE_READ_3;
                  end
                else
                  begin
                    state_nextA =  STATE_READ_2;
                  end
              end
            STATE_READ_3 : 
              begin
                if (scl_posedge)
                  begin
                    if (sda_i_regA)
                      begin
                        state_nextA =  STATE_IDLE;
                      end
                    else
                      begin
                        bit_count_nextA =  4'd7;
                        s_axis_data_tready_nextA =  1'b1;
                        data_valid_nextA =  1'b0;
                        state_nextA =  STATE_READ_1;
                      end
                  end
                else
                  begin
                    state_nextA =  STATE_READ_3;
                  end
              end
          endcase
        end
  end

always @*
  begin
    state_nextB =  STATE_IDLE;
    addr_nextB =  addr_regB;
    data_nextB =  data_regB;
    data_valid_nextB =  data_valid_regB;
    data_out_reg_valid_nextB =  data_out_reg_valid_regB;
    last_nextB =  last_regB;
    mode_read_nextB =  mode_read_regB;
    bit_count_nextB =  bit_count_regB;
    s_axis_data_tready_nextB =  1'b0;
    m_axis_data_tdata_nextB =  m_axis_data_tdata_regB;
    m_axis_data_tvalid_nextB =  m_axis_data_tvalid_regB&&!m_axis_data_treadyB;
    m_axis_data_tlast_nextB =  m_axis_data_tlast_regB;
    scl_o_nextB =  scl_o_regB;
    sda_o_nextB =  sda_o_regB;
    bus_addressed_nextB =  bus_addressed_regB;
    if (start_bit)
      begin
        data_valid_nextB =  1'b0;
        data_out_reg_valid_nextB =  1'b0;
        bit_count_nextB =  4'd7;
        m_axis_data_tlast_nextB =  1'b1;
        m_axis_data_tvalid_nextB =  data_out_reg_valid_regB;
        bus_addressed_nextB =  1'b0;
        state_nextB =  STATE_ADDRESS;
      end
    else
      if (release_busB||stop_bit)
        begin
          data_valid_nextB =  1'b0;
          data_out_reg_valid_nextB =  1'b0;
          m_axis_data_tlast_nextB =  1'b1;
          m_axis_data_tvalid_nextB =  data_out_reg_valid_regB;
          bus_addressed_nextB =  1'b0;
          state_nextB =  STATE_IDLE;
        end
      else
        begin
          case (state_regB)
            STATE_IDLE : 
              begin
                data_valid_nextB =  1'b0;
                data_out_reg_valid_nextB =  1'b0;
                bus_addressed_nextB =  1'b0;
                state_nextB =  STATE_IDLE;
              end
            STATE_ADDRESS : 
              begin
                if (scl_posedge)
                  begin
                    if (bit_count_regB>0)
                      begin
                        bit_count_nextB =  bit_count_regB-1;
                        data_nextB =  {data_regB[6:0] ,sda_i_regB};
                        state_nextB =  STATE_ADDRESS;
                      end
                    else
                      begin
                        if (enableB&&(device_addressB&device_address_maskB)==(data_regB[6:0] &device_address_maskB))
                          begin
                            addr_nextB =  data_regB[6:0] ;
                            mode_read_nextB =  sda_i_regB;
                            bus_addressed_nextB =  1'b1;
                            state_nextB =  STATE_ACK;
                          end
                        else
                          begin
                            state_nextB =  STATE_IDLE;
                          end
                      end
                  end
                else
                  begin
                    state_nextB =  STATE_ADDRESS;
                  end
              end
            STATE_ACK : 
              begin
                if (scl_negedge)
                  begin
                    sda_o_nextB =  1'b0;
                    bit_count_nextB =  4'd7;
                    if (mode_read_regB)
                      begin
                        s_axis_data_tready_nextB =  1'b1;
                        data_valid_nextB =  1'b0;
                        state_nextB =  STATE_READ_1;
                      end
                    else
                      begin
                        state_nextB =  STATE_WRITE_1;
                      end
                  end
                else
                  begin
                    state_nextB =  STATE_ACK;
                  end
              end
            STATE_WRITE_1 : 
              begin
                if (scl_negedge||!scl_o_regB)
                  begin
                    sda_o_nextB =  1'b1;
                    if (m_axis_data_tvalidB&&!m_axis_data_treadyB)
                      begin
                        scl_o_nextB =  1'b0;
                        state_nextB =  STATE_WRITE_1;
                      end
                    else
                      begin
                        scl_o_nextB =  1'b1;
                        if (data_valid_regB)
                          begin
                            m_axis_data_tdata_nextB =  data_regB;
                            m_axis_data_tlast_nextB =  1'b0;
                          end
                        data_valid_nextB =  1'b0;
                        data_out_reg_valid_nextB =  data_valid_regB;
                        state_nextB =  STATE_WRITE_2;
                      end
                  end
                else
                  begin
                    state_nextB =  STATE_WRITE_1;
                  end
              end
            STATE_WRITE_2 : 
              begin
                if (scl_posedge)
                  begin
                    data_nextB =  {data_regB[6:0] ,sda_i_regB};
                    if (bit_count_regB>0)
                      begin
                        bit_count_nextB =  bit_count_regB-1;
                        state_nextB =  STATE_WRITE_2;
                      end
                    else
                      begin
                        m_axis_data_tvalid_nextB =  data_out_reg_valid_regB;
                        data_out_reg_valid_nextB =  1'b0;
                        data_valid_nextB =  1'b1;
                        state_nextB =  STATE_ACK;
                      end
                  end
                else
                  begin
                    state_nextB =  STATE_WRITE_2;
                  end
              end
            STATE_READ_1 : 
              begin
                if (s_axis_data_treadyB&&s_axis_data_tvalidB)
                  begin
                    s_axis_data_tready_nextB =  1'b0;
                    data_nextB =  s_axis_data_tdataB;
                    data_valid_nextB =  1'b1;
                  end
                else
                  begin
                    s_axis_data_tready_nextB =  !data_valid_regB;
                  end
                if (scl_negedge||!scl_o_regB)
                  begin
                    if (!data_valid_regB)
                      begin
                        scl_o_nextB =  1'b0;
                        state_nextB =  STATE_READ_1;
                      end
                    else
                      begin
                        scl_o_nextB =  1'b1;
                        sda_o_nextB =  data_regB[7] ;
                        data_nextB =  {data_regB[6:0] ,1'b0};
                        if (bit_count_regB>0)
                          begin
                            bit_count_nextB =  bit_count_regB-1;
                            state_nextB =  STATE_READ_1;
                          end
                        else
                          begin
                            state_nextB =  STATE_READ_2;
                          end
                      end
                  end
                else
                  begin
                    state_nextB =  STATE_READ_1;
                  end
              end
            STATE_READ_2 : 
              begin
                if (scl_negedge)
                  begin
                    sda_o_nextB =  1'b1;
                    state_nextB =  STATE_READ_3;
                  end
                else
                  begin
                    state_nextB =  STATE_READ_2;
                  end
              end
            STATE_READ_3 : 
              begin
                if (scl_posedge)
                  begin
                    if (sda_i_regB)
                      begin
                        state_nextB =  STATE_IDLE;
                      end
                    else
                      begin
                        bit_count_nextB =  4'd7;
                        s_axis_data_tready_nextB =  1'b1;
                        data_valid_nextB =  1'b0;
                        state_nextB =  STATE_READ_1;
                      end
                  end
                else
                  begin
                    state_nextB =  STATE_READ_3;
                  end
              end
          endcase
        end
  end

always @*
  begin
    state_nextC =  STATE_IDLE;
    addr_nextC =  addr_regC;
    data_nextC =  data_regC;
    data_valid_nextC =  data_valid_regC;
    data_out_reg_valid_nextC =  data_out_reg_valid_regC;
    last_nextC =  last_regC;
    mode_read_nextC =  mode_read_regC;
    bit_count_nextC =  bit_count_regC;
    s_axis_data_tready_nextC =  1'b0;
    m_axis_data_tdata_nextC =  m_axis_data_tdata_regC;
    m_axis_data_tvalid_nextC =  m_axis_data_tvalid_regC&&!m_axis_data_treadyC;
    m_axis_data_tlast_nextC =  m_axis_data_tlast_regC;
    scl_o_nextC =  scl_o_regC;
    sda_o_nextC =  sda_o_regC;
    bus_addressed_nextC =  bus_addressed_regC;
    if (start_bit)
      begin
        data_valid_nextC =  1'b0;
        data_out_reg_valid_nextC =  1'b0;
        bit_count_nextC =  4'd7;
        m_axis_data_tlast_nextC =  1'b1;
        m_axis_data_tvalid_nextC =  data_out_reg_valid_regC;
        bus_addressed_nextC =  1'b0;
        state_nextC =  STATE_ADDRESS;
      end
    else
      if (release_busC||stop_bit)
        begin
          data_valid_nextC =  1'b0;
          data_out_reg_valid_nextC =  1'b0;
          m_axis_data_tlast_nextC =  1'b1;
          m_axis_data_tvalid_nextC =  data_out_reg_valid_regC;
          bus_addressed_nextC =  1'b0;
          state_nextC =  STATE_IDLE;
        end
      else
        begin
          case (state_regC)
            STATE_IDLE : 
              begin
                data_valid_nextC =  1'b0;
                data_out_reg_valid_nextC =  1'b0;
                bus_addressed_nextC =  1'b0;
                state_nextC =  STATE_IDLE;
              end
            STATE_ADDRESS : 
              begin
                if (scl_posedge)
                  begin
                    if (bit_count_regC>0)
                      begin
                        bit_count_nextC =  bit_count_regC-1;
                        data_nextC =  {data_regC[6:0] ,sda_i_regC};
                        state_nextC =  STATE_ADDRESS;
                      end
                    else
                      begin
                        if (enableC&&(device_addressC&device_address_maskC)==(data_regC[6:0] &device_address_maskC))
                          begin
                            addr_nextC =  data_regC[6:0] ;
                            mode_read_nextC =  sda_i_regC;
                            bus_addressed_nextC =  1'b1;
                            state_nextC =  STATE_ACK;
                          end
                        else
                          begin
                            state_nextC =  STATE_IDLE;
                          end
                      end
                  end
                else
                  begin
                    state_nextC =  STATE_ADDRESS;
                  end
              end
            STATE_ACK : 
              begin
                if (scl_negedge)
                  begin
                    sda_o_nextC =  1'b0;
                    bit_count_nextC =  4'd7;
                    if (mode_read_regC)
                      begin
                        s_axis_data_tready_nextC =  1'b1;
                        data_valid_nextC =  1'b0;
                        state_nextC =  STATE_READ_1;
                      end
                    else
                      begin
                        state_nextC =  STATE_WRITE_1;
                      end
                  end
                else
                  begin
                    state_nextC =  STATE_ACK;
                  end
              end
            STATE_WRITE_1 : 
              begin
                if (scl_negedge||!scl_o_regC)
                  begin
                    sda_o_nextC =  1'b1;
                    if (m_axis_data_tvalidC&&!m_axis_data_treadyC)
                      begin
                        scl_o_nextC =  1'b0;
                        state_nextC =  STATE_WRITE_1;
                      end
                    else
                      begin
                        scl_o_nextC =  1'b1;
                        if (data_valid_regC)
                          begin
                            m_axis_data_tdata_nextC =  data_regC;
                            m_axis_data_tlast_nextC =  1'b0;
                          end
                        data_valid_nextC =  1'b0;
                        data_out_reg_valid_nextC =  data_valid_regC;
                        state_nextC =  STATE_WRITE_2;
                      end
                  end
                else
                  begin
                    state_nextC =  STATE_WRITE_1;
                  end
              end
            STATE_WRITE_2 : 
              begin
                if (scl_posedge)
                  begin
                    data_nextC =  {data_regC[6:0] ,sda_i_regC};
                    if (bit_count_regC>0)
                      begin
                        bit_count_nextC =  bit_count_regC-1;
                        state_nextC =  STATE_WRITE_2;
                      end
                    else
                      begin
                        m_axis_data_tvalid_nextC =  data_out_reg_valid_regC;
                        data_out_reg_valid_nextC =  1'b0;
                        data_valid_nextC =  1'b1;
                        state_nextC =  STATE_ACK;
                      end
                  end
                else
                  begin
                    state_nextC =  STATE_WRITE_2;
                  end
              end
            STATE_READ_1 : 
              begin
                if (s_axis_data_treadyC&&s_axis_data_tvalidC)
                  begin
                    s_axis_data_tready_nextC =  1'b0;
                    data_nextC =  s_axis_data_tdataC;
                    data_valid_nextC =  1'b1;
                  end
                else
                  begin
                    s_axis_data_tready_nextC =  !data_valid_regC;
                  end
                if (scl_negedge||!scl_o_regC)
                  begin
                    if (!data_valid_regC)
                      begin
                        scl_o_nextC =  1'b0;
                        state_nextC =  STATE_READ_1;
                      end
                    else
                      begin
                        scl_o_nextC =  1'b1;
                        sda_o_nextC =  data_regC[7] ;
                        data_nextC =  {data_regC[6:0] ,1'b0};
                        if (bit_count_regC>0)
                          begin
                            bit_count_nextC =  bit_count_regC-1;
                            state_nextC =  STATE_READ_1;
                          end
                        else
                          begin
                            state_nextC =  STATE_READ_2;
                          end
                      end
                  end
                else
                  begin
                    state_nextC =  STATE_READ_1;
                  end
              end
            STATE_READ_2 : 
              begin
                if (scl_negedge)
                  begin
                    sda_o_nextC =  1'b1;
                    state_nextC =  STATE_READ_3;
                  end
                else
                  begin
                    state_nextC =  STATE_READ_2;
                  end
              end
            STATE_READ_3 : 
              begin
                if (scl_posedge)
                  begin
                    if (sda_i_regC)
                      begin
                        state_nextC =  STATE_IDLE;
                      end
                    else
                      begin
                        bit_count_nextC =  4'd7;
                        s_axis_data_tready_nextC =  1'b1;
                        data_valid_nextC =  1'b0;
                        state_nextC =  STATE_READ_1;
                      end
                  end
                else
                  begin
                    state_nextC =  STATE_READ_3;
                  end
              end
          endcase
        end
  end

always @( posedge clkA )
  begin
    state_regA <= state_nextA;
    addr_regA <= addr_nextA;
    data_regA <= data_nextA;
    data_valid_regA <= data_valid_nextA;
    data_out_reg_valid_regA <= data_out_reg_valid_nextA;
    last_regA <= last_nextA;
    mode_read_regA <= mode_read_nextA;
    bit_count_regA <= bit_count_nextA;
    s_axis_data_tready_regA <= s_axis_data_tready_nextA;
    m_axis_data_tdata_regA <= m_axis_data_tdata_nextA;
    m_axis_data_tvalid_regA <= m_axis_data_tvalid_nextA;
    m_axis_data_tlast_regA <= m_axis_data_tlast_nextA;
    scl_i_filterA <= (scl_i_filterA<<1)|scl_iA;
    sda_i_filterA <= (sda_i_filterA<<1)|sda_iA;
    if (scl_i_filterA=={ FILTER_LEN {1'b1} } )
      begin
        scl_i_regA <= 1'b1;
      end
    else
      if (scl_i_filterA=={ FILTER_LEN {1'b0} } )
        begin
          scl_i_regA <= 1'b0;
        end
    if (sda_i_filterA=={ FILTER_LEN {1'b1} } )
      begin
        sda_i_regA <= 1'b1;
      end
    else
      if (sda_i_filterA=={ FILTER_LEN {1'b0} } )
        begin
          sda_i_regA <= 1'b0;
        end
    scl_o_regA <= scl_o_nextA;
    sda_o_regA <= sda_o_nextA;
    last_scl_i_regA <= scl_i_regA;
    last_sda_i_regA <= sda_i_regA;
    busy_regA <= !(state_regA==STATE_IDLE);
    if (start_bit)
      begin
        bus_active_regA <= 1'b1;
      end
    else
      if (stop_bit)
        begin
          bus_active_regA <= 1'b0;
        end
      else
        begin
          bus_active_regA <= bus_active_regA;
        end
    bus_addressed_regA <= bus_addressed_nextA;
    if (rstA)
      begin
        state_regA <= STATE_IDLE;
        s_axis_data_tready_regA <= 1'b0;
        m_axis_data_tvalid_regA <= 1'b0;
        scl_o_regA <= 1'b1;
        sda_o_regA <= 1'b1;
        busy_regA <= 1'b0;
        bus_active_regA <= 1'b0;
        bus_addressed_regA <= 1'b0;
        data_valid_regA <= 1'b0;
        data_out_reg_valid_regA <= 1'b0;
        last_regA <= 1'b0;
        mode_read_regA <= 1'b0;
        m_axis_data_tlast_regA <= 1'b0;
        scl_i_filterA <= {FILTER_LEN{1'b1}};
        sda_i_filterA <= {FILTER_LEN{1'b1}};
        scl_i_regA <= 1'b1;
        sda_i_regA <= 1'b1;
        last_scl_i_regA <= 1'b1;
        last_sda_i_regA <= 1'b1;
      end
  end

always @( posedge clkB )
  begin
    state_regB <= state_nextB;
    addr_regB <= addr_nextB;
    data_regB <= data_nextB;
    data_valid_regB <= data_valid_nextB;
    data_out_reg_valid_regB <= data_out_reg_valid_nextB;
    last_regB <= last_nextB;
    mode_read_regB <= mode_read_nextB;
    bit_count_regB <= bit_count_nextB;
    s_axis_data_tready_regB <= s_axis_data_tready_nextB;
    m_axis_data_tdata_regB <= m_axis_data_tdata_nextB;
    m_axis_data_tvalid_regB <= m_axis_data_tvalid_nextB;
    m_axis_data_tlast_regB <= m_axis_data_tlast_nextB;
    scl_i_filterB <= (scl_i_filterB<<1)|scl_iB;
    sda_i_filterB <= (sda_i_filterB<<1)|sda_iB;
    if (scl_i_filterB=={ FILTER_LEN {1'b1} } )
      begin
        scl_i_regB <= 1'b1;
      end
    else
      if (scl_i_filterB=={ FILTER_LEN {1'b0} } )
        begin
          scl_i_regB <= 1'b0;
        end
    if (sda_i_filterB=={ FILTER_LEN {1'b1} } )
      begin
        sda_i_regB <= 1'b1;
      end
    else
      if (sda_i_filterB=={ FILTER_LEN {1'b0} } )
        begin
          sda_i_regB <= 1'b0;
        end
    scl_o_regB <= scl_o_nextB;
    sda_o_regB <= sda_o_nextB;
    last_scl_i_regB <= scl_i_regB;
    last_sda_i_regB <= sda_i_regB;
    busy_regB <= !(state_regB==STATE_IDLE);
    if (start_bit)
      begin
        bus_active_regB <= 1'b1;
      end
    else
      if (stop_bit)
        begin
          bus_active_regB <= 1'b0;
        end
      else
        begin
          bus_active_regB <= bus_active_regB;
        end
    bus_addressed_regB <= bus_addressed_nextB;
    if (rstB)
      begin
        state_regB <= STATE_IDLE;
        s_axis_data_tready_regB <= 1'b0;
        m_axis_data_tvalid_regB <= 1'b0;
        scl_o_regB <= 1'b1;
        sda_o_regB <= 1'b1;
        busy_regB <= 1'b0;
        bus_active_regB <= 1'b0;
        bus_addressed_regB <= 1'b0;
        data_valid_regB <= 1'b0;
        data_out_reg_valid_regB <= 1'b0;
        last_regB <= 1'b0;
        mode_read_regB <= 1'b0;
        m_axis_data_tlast_regB <= 1'b0;
        scl_i_filterB <= {FILTER_LEN{1'b1}};
        sda_i_filterB <= {FILTER_LEN{1'b1}};
        scl_i_regB <= 1'b1;
        sda_i_regB <= 1'b1;
        last_scl_i_regB <= 1'b1;
        last_sda_i_regB <= 1'b1;
      end
  end

always @( posedge clkC )
  begin
    state_regC <= state_nextC;
    addr_regC <= addr_nextC;
    data_regC <= data_nextC;
    data_valid_regC <= data_valid_nextC;
    data_out_reg_valid_regC <= data_out_reg_valid_nextC;
    last_regC <= last_nextC;
    mode_read_regC <= mode_read_nextC;
    bit_count_regC <= bit_count_nextC;
    s_axis_data_tready_regC <= s_axis_data_tready_nextC;
    m_axis_data_tdata_regC <= m_axis_data_tdata_nextC;
    m_axis_data_tvalid_regC <= m_axis_data_tvalid_nextC;
    m_axis_data_tlast_regC <= m_axis_data_tlast_nextC;
    scl_i_filterC <= (scl_i_filterC<<1)|scl_iC;
    sda_i_filterC <= (sda_i_filterC<<1)|sda_iC;
    if (scl_i_filterC=={ FILTER_LEN {1'b1} } )
      begin
        scl_i_regC <= 1'b1;
      end
    else
      if (scl_i_filterC=={ FILTER_LEN {1'b0} } )
        begin
          scl_i_regC <= 1'b0;
        end
    if (sda_i_filterC=={ FILTER_LEN {1'b1} } )
      begin
        sda_i_regC <= 1'b1;
      end
    else
      if (sda_i_filterC=={ FILTER_LEN {1'b0} } )
        begin
          sda_i_regC <= 1'b0;
        end
    scl_o_regC <= scl_o_nextC;
    sda_o_regC <= sda_o_nextC;
    last_scl_i_regC <= scl_i_regC;
    last_sda_i_regC <= sda_i_regC;
    busy_regC <= !(state_regC==STATE_IDLE);
    if (start_bit)
      begin
        bus_active_regC <= 1'b1;
      end
    else
      if (stop_bit)
        begin
          bus_active_regC <= 1'b0;
        end
      else
        begin
          bus_active_regC <= bus_active_regC;
        end
    bus_addressed_regC <= bus_addressed_nextC;
    if (rstC)
      begin
        state_regC <= STATE_IDLE;
        s_axis_data_tready_regC <= 1'b0;
        m_axis_data_tvalid_regC <= 1'b0;
        scl_o_regC <= 1'b1;
        sda_o_regC <= 1'b1;
        busy_regC <= 1'b0;
        bus_active_regC <= 1'b0;
        bus_addressed_regC <= 1'b0;
        data_valid_regC <= 1'b0;
        data_out_reg_valid_regC <= 1'b0;
        last_regC <= 1'b0;
        mode_read_regC <= 1'b0;
        m_axis_data_tlast_regC <= 1'b0;
        scl_i_filterC <= {FILTER_LEN{1'b1}};
        sda_i_filterC <= {FILTER_LEN{1'b1}};
        scl_i_regC <= 1'b1;
        sda_i_regC <= 1'b1;
        last_scl_i_regC <= 1'b1;
        last_sda_i_regC <= 1'b1;
      end
  end

majorityVoter last_scl_i_regVoter (
    .inA(last_scl_i_regA),
    .inB(last_scl_i_regB),
    .inC(last_scl_i_regC),
    .out(last_scl_i_reg),
    .tmrErr(last_scl_i_regTmrError)
    );

majorityVoter last_sda_i_regVoter (
    .inA(last_sda_i_regA),
    .inB(last_sda_i_regB),
    .inC(last_sda_i_regC),
    .out(last_sda_i_reg),
    .tmrErr(last_sda_i_regTmrError)
    );

majorityVoter scl_i_regVoter (
    .inA(scl_i_regA),
    .inB(scl_i_regB),
    .inC(scl_i_regC),
    .out(scl_i_reg),
    .tmrErr(scl_i_regTmrError)
    );

majorityVoter sda_i_regVoter (
    .inA(sda_i_regA),
    .inB(sda_i_regB),
    .inC(sda_i_regC),
    .out(sda_i_reg),
    .tmrErr(sda_i_regTmrError)
    );

fanout clkFanout (
    .in(clk),
    .outA(clkA),
    .outB(clkB),
    .outC(clkC)
    );

fanout rstFanout (
    .in(rst),
    .outA(rstA),
    .outB(rstB),
    .outC(rstC)
    );
endmodule

